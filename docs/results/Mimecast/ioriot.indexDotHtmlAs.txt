b'<html lang="en-US">\n <head>\n  <meta charset="utf-8"/>\n  <meta content="IE=edge" http-equiv="X-UA-Compatible"/>\n  <meta content="width=device-width,initial-scale=1" name="viewport"/>\n  <link href="/ioriot/assets/css/style.css?v=fbf1757f0210ee1b941d1e016fb74d852091f74b" rel="stylesheet"/>\n  <script crossorigin="anonymous" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" src="https://code.jquery.com/jquery-1.12.4.min.js">\n  </script>\n  <script src="/ioriot/assets/js/script.js">\n  </script>\n  <!-- Begin Jekyll SEO tag v2.5.0 -->\n  <title>\n   I/O Riot | ioriot\n  </title>\n  <meta content="Jekyll v3.7.4" name="generator"/>\n  <meta content="I/O Riot" property="og:title"/>\n  <meta content="en_US" property="og:locale"/>\n  <meta content="I/O Riot is a tool for logging, replaying, and benchmarking I/O on Linux" name="description"/>\n  <meta content="I/O Riot is a tool for logging, replaying, and benchmarking I/O on Linux" property="og:description"/>\n  <link href="https://mimecast.github.io/ioriot/" rel="canonical"/>\n  <meta content="https://mimecast.github.io/ioriot/" property="og:url"/>\n  <meta content="ioriot" property="og:site_name"/>\n  <script type="application/ld+json">\n   {"@type":"WebSite","headline":"I/O Riot","url":"https://mimecast.github.io/ioriot/","name":"ioriot","description":"I/O Riot is a tool for logging, replaying, and benchmarking I/O on Linux","@context":"http://schema.org"}\n  </script>\n  <!-- End Jekyll SEO tag -->\n </head>\n <body>\n  <div class="wrapper">\n   <header>\n    <h1 class="title">\n     ioriot\n    </h1>\n   </header>\n   <div id="container">\n    <p class="tagline">\n     I/O Riot is a tool for logging, replaying, and benchmarking I/O on Linux\n    </p>\n    <div id="main" role="main">\n     <div class="download-bar">\n      <div class="inner">\n       <a class="code" href="https://github.com/Mimecast/ioriot">\n        View ioriot on GitHub\n       </a>\n      </div>\n      <span class="blc">\n      </span>\n      <span class="trc">\n      </span>\n     </div>\n     <article class="markdown-body">\n      <h1 id="io-riot">\n       I/O Riot\n      </h1>\n      <h2 id="overview">\n       Overview\n      </h2>\n      <p>\n       I/O Riot is an I/O benchmarking tool for Linux based operating systems which captures I/O operations on a (possibly production) server in order to replay the exact same I/O operations on a load test machine.\n      </p>\n      <p>\n       I/O Riot is operated in 5 steps:\n      </p>\n      <ol>\n       <li>\n        Capture: Record all I/O operations over a given period of time to a capture log.\n       </li>\n       <li>\n        Initialize: Copy the log to a load test machine and initialize the load test environment.\n       </li>\n       <li>\n        Replay: Drop all OS caches and replay all I/O operations.\n       </li>\n       <li>\n        Analyze: Look at the OS and hardware stats (throughput, I/O ops, load average) from the run phase and draw conclusions. The aim is to identify possible I/O bottlenecks.\n       </li>\n       <li>\n        Repeat: Repeat steps 2-4 multiple times but adjust OS and hardware settings in order to improve I/O performance.\n       </li>\n      </ol>\n      <p>\n       Examples of OS and hardware settings and adjustments:\n      </p>\n      <ul>\n       <li>\n        Change of system parameters (file system mount options, file system caching, file system type, file system creation flags).\n       </li>\n       <li>\n        Replay the I/O at different speed(s).\n       </li>\n       <li>\n        Replay the I/O with modified pattern(s) (e.g. remove reads from the replay journal).\n       </li>\n       <li>\n        Replay the I/O on different types of hardware.\n       </li>\n      </ul>\n      <p>\n       The file system fragmentation (depending on the file system type and utilisation) might affect I/O performance as well. Therefore, replaying the I/O will not give the exact same result as on a production system. But it provides a pretty good way to determine I/O bottlenecks. As a rule of thumb file system fragmentation will not be an issue, unless the file system begins to fill up. Modern file systems (such as Ext4) will slowly start to suffer from fragmentation and slow down then.\n      </p>\n      <h2 id="benefits">\n       Benefits\n      </h2>\n      <p>\n       In contrast to traditional I/O benchmarking tools, I/O Riot reproduces real production I/O, and does not rely on a pre-defined set of I/O operations.\n      </p>\n      <p>\n       Also, I/O Riot only requires a server machine for capturing and another server machine for replaying. A traditional load test environment would usually be a distributed system which can consist of many components and machines. Such a distributed system can become quite complex which makes it difficult to isolate possible I/O bottlenecks. For example in order to trigger I/O events a client application would usually have to call a remote server application. The remote server application itself would query a database and the database would trigger the actual I/O operations in Linux. Furthermore, it is not easy to switch forth and back between hardware and OS settings. For example without a backup and restore procedure a database would most likely be corrupt after reformatting the data partitions with a different file system type.\n      </p>\n      <p>\n       The benefits of I/O Riot are:\n      </p>\n      <ul>\n       <li>\n        It is easy to determine whether a new hardware type is suitable for an already existing application.\n       </li>\n       <li>\n        It is easy to change OS and hardware for performance tests and optimizations.\n       </li>\n       <li>\n        Findings can be applied to production machines in order to optimize OS configuration and to save hardware costs.\n       </li>\n       <li>\n        Benchmarks are based on production I/O patterns and not on artificial I/O patterns.\n       </li>\n       <li>\n        Log files can be modified to see whether a change in the application behavior would improve I/O performance (without actually touching the application code)\n       </li>\n       <li>\n        Log files could be generated synthetically in order to find out how a new application would perform (even if there isn\xe2\x80\x99t any code for the new application yet)\n       </li>\n       <li>\n        It identifies possible flaws in the applications (e.g. Java programs which produce I/O operations on the server machines). Findings can be reported to the corresponding developers so that changes can be introduced to improve the applications I/O performance.\n       </li>\n       <li>\n        It captures I/O in Linux Kernel space (very efficient, no system slowdowns even under heavy I/O load)\n       </li>\n       <li>\n        It replays I/O via a tool developed in C with as little overhead as possible.\n       </li>\n      </ul>\n      <h1 id="send-in-patches">\n       Send in patches\n      </h1>\n      <p>\n       Patches of any kind (bug fixes, new features\xe2\x80\xa6) are welcome! I/O Riot is new software and not everything might be perfect yet. Also, I/O Riot is used for a very specific use case at Mimecast. It may need tuning or extension for your use case. It will grow and mature over time.\n      </p>\n      <p>\n       This is also potentially a great tool just for analysing (not replaying) the I/O, therefore it would be a great opportunity to add more features related to that (e.g. more stats, filters, etc.).\n      </p>\n      <p>\n       Future work will also include file hole support and I/O support for memory mapped files.\n      </p>\n      <h1 id="how-to-install-io-riot">\n       How to install I/O Riot\n      </h1>\n      <p>\n       I/O Riot depends on SystemTap and a compatible version of the Linux Kernel. To get started have a read through the\n       <a href="/ioriot/docs/markdown/installation.html">\n        installation guide\n       </a>\n       .\n      </p>\n      <h1 id="how-to-use-io-riot">\n       How to use I/O Riot\n      </h1>\n      <p>\n       Check out the\n       <a href="/ioriot/docs/markdown/usage.html">\n        I/O Riot usage guide\n       </a>\n       for a full usage workflow demonstration.\n      </p>\n      <h1 id="appendix">\n       Appendix\n      </h1>\n      <h2 id="supported-file-systems">\n       Supported file systems\n      </h2>\n      <p>\n       Currently I/O Riot supports replaying I/O on\n       <code class="highlighter-rouge">\n        ext2\n       </code>\n       ,\n       <code class="highlighter-rouge">\n        ext3\n       </code>\n       ,\n       <code class="highlighter-rouge">\n        ext4\n       </code>\n       and\n       <code class="highlighter-rouge">\n        xfs\n       </code>\n       . However, it should be straightforward add additional file systems.\n      </p>\n      <h2 id="supported-syscalls">\n       Supported syscalls\n      </h2>\n      <p>\n       Currently, these file I/O related syscalls are supported (as of CentOS 7):\n      </p>\n      <pre class="lines">1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n</pre>\n      <pre><code class="language-code">open\nopenat\nlseek\nllseek\nfcntl\ncreat\nwrite\nwritev\nunlink\nunlinkat\nrename\nrenameat\nrenameat2\nread\nreadv\nreadahead - Initial support only\nreaddir\nreadlink\nreadlinkat\nfdatasync\nfsync\nsync_file_range - Initial support only\nsync\nsyncfs\nclose\ngetdents\nmkdir\nrmdir\nmkdirat\nstat\nstatfs - Initial support only\nstatfs64 - Initial support only\nfstatfs - Initial support only\nfstatfs64 - Initial support only\nlstat\nfstat\nfstatat\nchmod\nfchmodat\nfchmod\nchown\nchown16\nlchown\nlchown16\nfchown\nfchown16\nfchownat\nmmap2 - Initial support only\nmremap - Initial support only\nmunmap - Initial support only\nmsync - Initial support only\nexit_group - To detect process termination (closing all open file handles)\n</code></pre>\n      <h2 id="source-code-documentation">\n       Source code documentation\n      </h2>\n      <p>\n       The documentation of the source code can be generated via the Doxygen Framework. To install doxygen run\n       <code class="highlighter-rouge">\n        sudo yum install doxygen\n       </code>\n       and to generate the documentation run\n       <code class="highlighter-rouge">\n        make doxygen\n       </code>\n       in the top level source directory.  Once done, the resulting documentation can be found in the\n       <code class="highlighter-rouge">\n        docs/html\n       </code>\n       subfolder of the project. It is worthwhile to start from\n       <code class="highlighter-rouge">\n        ioriot/src/main.c\n       </code>\n       and read your way through. Functions are generally documented in the header files. Exceptions are static functions which don\xe2\x80\x99t have any separate declarations.\n      </p>\n     </article>\n    </div>\n   </div>\n   <footer>\n    <div class="owner">\n     <p>\n      <a class="avatar" href="https://github.com/Mimecast">\n       <img height="48" src="https://github.com/Mimecast.png" width="48"/>\n      </a>\n      <a href="https://github.com/Mimecast">\n       Mimecast\n      </a>\n      maintains\n      <a href="https://github.com/Mimecast/ioriot">\n       ioriot\n      </a>\n     </p>\n    </div>\n    <div class="creds">\n     <small>\n      This page generated using\n      <a href="https://pages.github.com/">\n       GitHub Pages\n      </a>\n      <br/>\n      theme by\n      <a href="https://twitter.com/jonrohan/">\n       Jon Rohan\n      </a>\n     </small>\n    </div>\n   </footer>\n  </div>\n  <div class="current-section">\n   <a href="#top">\n    Scroll to top\n   </a>\n   <a class="tar" href="https://github.com/Mimecast/ioriot/tarball/master">\n    tar\n   </a>\n   <a class="zip" href="https://github.com/Mimecast/ioriot/zipball/master">\n    zip\n   </a>\n   <a class="code" href="">\n    source code\n   </a>\n   <p class="name">\n   </p>\n  </div>\n </body>\n</html>'